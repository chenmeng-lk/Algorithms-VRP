# FILO2算法代码调用流程说明

## 概述
FILO2是一个用于求解带容量约束的车辆路径问题(CVRP)的启发式算法。该算法结合了多种优化技术，包括Clarke-Wright初始解构造、路径最小化、局部搜索和模拟退火。

## 主要文件结构

```
filo2/
├── main.cpp                    # 主程序入口
├── Parameters.hpp              # 参数管理
├── instance/
│   ├── Instance.hpp/cpp        # 问题实例管理
│   └── Parser.hpp/cpp          # 实例文件解析
├── solution/
│   ├── Solution.hpp/cpp        # 解的数据结构和操作
│   └── savings.hpp             # Clarke-Wright节约算法
├── opt/
│   ├── bpp.hpp                 # 装箱问题求解（估计最少路径数）
│   ├── routemin.hpp            # 路径最小化算法
│   ├── RuinAndRecreate.hpp     # 破坏-重构算子
│   └── SimulatedAnnealing.hpp  # 模拟退火接受准则
├── localsearch/
│   ├── LocalSearch.hpp         # 局部搜索框架
│   ├── AbstractOperator.hpp    # 邻域算子抽象基类
│   ├── OneOneExchange.hpp      # 1-1交换算子
│   ├── OneZeroExchange.hpp     # 1-0交换算子
│   ├── TwoOptExchange.hpp      # 2-opt算子
│   ├── TailsExchange.hpp       # 尾部交换算子
│   ├── SplitExchange.hpp       # 分割算子
│   ├── EjectionChain.hpp       # 弹射链算子
│   └── ...                     # 其他邻域算子
├── movegen/
│   └── MoveGenerators.hpp      # 移动生成器（粒度规则）
└── base/
    ├── Timer.hpp               # 计时器
    ├── Welford.hpp             # 在线统计
    ├── LRUCache.hpp            # LRU缓存
    └── ...                     # 其他基础工具
```

## 算法执行流程

### 1. 初始化阶段 (main.cpp: 行30-83)

```
main()
  ├── 解析命令行参数 (Parameters)
  ├── 加载CVRP实例 (Instance::make)
  │   ├── 解析实例文件 (Parser)
  │   └── 预计算每个顶点的k近邻
  └── 创建解对象 (Solution)
```

**关键数据结构：**
- `Instance`: 存储客户位置、需求、距离矩阵、邻居列表
- `Solution`: 使用双向链表存储路径，支持高效的插入/删除操作

### 2. 初始解构造 (main.cpp: 行64-68)

```
clarke_and_wright() [solution/savings.hpp]
  ├── 为每个客户创建单客户路径
  ├── 计算所有客户对的节约值: s(i,j) = c(0,i) + c(0,j) - λ*c(i,j)
  ├── 按节约值降序排序
  └── 贪心合并路径（如果满足容量约束）
```

**输出：** 一个可行的CVRP解

### 3. 移动生成器设置 (main.cpp: 行77-89)

```
MoveGenerators(instance, k) [movegen/MoveGenerators.hpp]
  ├── 为每个顶点i，选择k个最近邻居j
  ├── 创建移动生成器(i,j)和(j,i)
  └── 支持动态调整活跃邻居数（粒度规则）
```

**作用：** 稀疏化搜索空间，只考虑有希望的移动

### 4. 路径数估计 (main.cpp: 行97-102)

```
greedy_first_fit_decreasing() [opt/bpp.hpp]
  ├── 按需求量降序排列客户
  └── 使用FFD算法估计最少路径数kmin
```

**输出：** 最少路径数的下界估计

### 5. 路径最小化（可选）(main.cpp: 行126-145)

```
routemin() [opt/routemin.hpp]
  如果 kmin < 当前路径数:
    ├── 循环max_iter次:
    │   ├── 随机选择1-2条路径
    │   ├── 移除路径中的所有客户
    │   ├── 按需求或随机顺序重新插入客户
    │   ├── 允许部分客户未被服务（概率性）
    │   ├── 应用局部搜索
    │   └── 如果找到更好的解，更新最优解
    └── 返回路径数减少的解
```

**目标：** 减少路径数量，同时保持或改进解的质量

### 6. 局部搜索设置 (main.cpp: 行147-170)

```
RandomizedVariableNeighborhoodDescent (RVND)
  ├── RVND0: 包含22种邻域算子
  │   ├── E11, E10: 交换算子
  │   ├── TAILS: 尾部交换
  │   ├── SPLIT: 分割操作
  │   ├── TWOPT: 2-opt
  │   ├── RE22B, RE22S, ...: 反向交换算子
  │   └── ...
  └── RVND1: 弹射链算子 (EJCH)
```

**策略：** 随机化邻域顺序，每次迭代应用所有算子一次

### 7. 核心优化循环 (main.cpp: 行298-519)

这是算法的核心部分，迭代地改进解。

```
for iter = 1 to coreopt_iterations:

  ┌─────────────────────────────────────────────────────────┐
  │ 7.1 恢复到参考解                                         │
  ├─────────────────────────────────────────────────────────┤
  │ neighbor.apply_undo_list1(neighbor)                     │
  │ neighbor.clear_svc()                                    │
  └─────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────┐
  │ 7.2 破坏-重构 (Ruin and Recreate)                       │
  ├─────────────────────────────────────────────────────────┤
  │ rr.apply(neighbor, omega) [opt/RuinAndRecreate.hpp]    │
  │   ├── 随机选择种子客户seed                              │
  │   ├── 从seed开始，移除omega[seed]个客户                 │
  │   │   ├── 在当前路径内移动（概率50%）                    │
  │   │   └── 跳转到邻居路径（概率50%）                      │
  │   ├── 对移除的客户排序（随机/按需求/按距离）             │
  │   └── 贪心重新插入客户到最佳位置                         │
  └─────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────┐
  │ 7.3 局部搜索                                             │
  ├─────────────────────────────────────────────────────────┤
  │ local_search.sequential_apply(neighbor)                 │
  │   ├── 应用RVND0（22种邻域算子）                          │
  │   └── 应用RVND1（弹射链）                                │
  └─────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────┐
  │ 7.4 更新最优解和参数                                     │
  ├─────────────────────────────────────────────────────────┤
  │ if neighbor.cost < best_solution.cost:                  │
  │   ├── 更新最优解                                         │
  │   └── 重置gamma参数（强化策略）                          │
  │ else:                                                   │
  │   └── 增加未改进顶点的gamma计数器                        │
  │       └── 如果超过阈值，增加gamma值（扩大搜索空间）       │
  └─────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────┐
  │ 7.5 自适应调整omega参数                                  │
  ├─────────────────────────────────────────────────────────┤
  │ if neighbor.cost > reference.cost + shaking_ub:         │
  │   └── 减少omega（扰动太强）                              │
  │ else if neighbor.cost < reference.cost + shaking_lb:    │
  │   └── 增加omega（扰动太弱）                              │
  │ else:                                                   │
  │   └── 随机调整omega                                      │
  └─────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────┐
  │ 7.6 模拟退火接受准则                                     │
  ├─────────────────────────────────────────────────────────┤
  │ if sa.accept(reference_cost, neighbor):                 │
  │   ├── 接受neighbor作为新的参考解                         │
  │   ├── 更新reference_solution_cost                       │
  │   └── 重新计算shaking界限                                │
  │ sa.decrease_temperature()                               │
  └─────────────────────────────────────────────────────────┘
```

### 8. 结果输出 (main.cpp: 行521-563)

```
输出最优解
  ├── 保存目标值和运行时间到.out文件
  └── 保存详细路径到.vrp.sol文件
```

## 关键算法组件详解

### 解的数据结构 (Solution.hpp)

```
Solution类:
  ├── 路径表示：双向链表
  │   ├── customers_list[i]: 客户i的前驱、后继、所属路径
  │   └── routes_list[r]: 路径r的首客户、尾客户、负载
  ├── LRU缓存 (SVC - Set of Visited Customers)
  │   └── 跟踪最近修改的顶点，用于增量更新
  ├── Do/Undo列表
  │   ├── do_list1: 当前迭代的修改
  │   ├── do_list2: 之前接受的修改
  │   └── undo_list1: 撤销操作
  └── 操作：
      ├── insert_vertex_before(): 在指定位置插入顶点
      ├── remove_vertex(): 移除顶点
      ├── reverse_route_path(): 反转路径片段
      ├── swap_tails(): 交换路径尾部
      └── split(): 分割操作
```

### 粒度规则 (MoveGenerators.hpp)

```
粒度规则（Granularity Rule）:
  ├── 目的：减少搜索空间
  ├── 策略：只考虑每个顶点的k个最近邻居
  ├── 动态调整：
  │   ├── gamma[i]: 顶点i的活跃邻居比例
  │   ├── 初始值：gamma_base (默认0.25)
  │   ├── 如果顶点i长时间未改进：gamma[i] *= 2（最大1.0）
  │   └── 如果找到更好的解：重置gamma[i] = gamma_base
  └── 实现：
      ├── 预计算k近邻
      ├── 维护活跃移动生成器列表
      └── 支持O(1)时间更新
```

### 破坏-重构算子 (RuinAndRecreate.hpp)

```
破坏阶段:
  ├── 选择种子客户seed
  ├── 移除omega[seed]个客户
  │   ├── 随机游走策略
  │   │   ├── 在当前路径内移动（前驱或后继）
  │   │   └── 跳转到邻居路径
  │   └── 记录被移除的客户

重构阶段:
  ├── 对移除的客户排序
  │   ├── 随机顺序
  │   ├── 按需求降序
  │   ├── 按到仓库距离降序
  │   └── 按到仓库距离升序
  └── 贪心插入
      ├── 只考虑服务邻居客户的路径
      ├── 计算最佳插入位置
      └── 如果无法插入，创建新路径
```

### 局部搜索算子

FILO2使用多种邻域算子，每种算子定义了不同的移动方式：

#### 基本交换算子
- **E10 (1-0 Exchange)**: 将一个客户从一条路径移动到另一条路径
- **E11 (1-1 Exchange)**: 交换两条路径中的两个客户
- **E20 (2-0 Exchange)**: 将两个连续客户从一条路径移动到另一条路径
- **E21 (2-1 Exchange)**: 交换一条路径中的两个连续客户和另一条路径中的一个客户
- **E22 (2-2 Exchange)**: 交换两条路径中的两对连续客户
- **E30, E31, E32, E33**: 类似的3-x交换

#### 反向交换算子
- **RE20, RE21, RE22, RE30, RE31, RE32, RE33**: 与上述算子类似，但会反转移动的客户序列
- **RE22B, RE22S**: 2-2反向交换的大邻域和小邻域版本

#### 特殊算子
- **TWOPT (2-opt)**: 反转路径中的一段
- **TAILS**: 交换两条路径的尾部
- **SPLIT**: 分割操作，重新分配两条路径的客户
- **EJCH (Ejection Chain)**: 弹射链，一系列连锁的客户移动

## 参数说明

### 命令行参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `--neighbors-num` | 1500 | 预计算的邻居数量 |
| `--granular-neighbors` | 25 | 粒度规则中的k值 |
| `--granular-gamma-base` | 0.25 | gamma初始值 |
| `--granular-delta` | 0.50 | delta值（用于计算gamma更新阈值） |
| `--cache` | 50 | 解缓存大小 |
| `--routemin-iterations` | 1000 | 路径最小化迭代次数 |
| `--coreopt-iterations` | 100000 | 核心优化迭代次数 |
| `--shaking-lower-bound` | 0.375 | 扰动强度下界因子 |
| `--shaking-upper-bound` | 0.85 | 扰动强度上界因子 |
| `--sa-initial-factor` | 0.1 | 模拟退火初始温度因子 |
| `--sa-final-factor` | 0.01 | 模拟退火最终温度因子 |
| `--tolerance` | 0.01 | 容差值 |
| `--seed` | 0 | 随机种子 |
| `--outpath` | ./ | 输出路径 |

### 关键参数的作用

#### Gamma参数（粒度规则）
- **gamma[i]**: 顶点i的活跃邻居比例（0到1之间）
- **作用**: 控制搜索空间的大小
- **动态调整**:
  - 如果顶点长时间未改进，增加gamma（扩大搜索空间）
  - 如果找到更好的解，重置gamma（强化当前区域）

#### Omega参数（扰动强度）
- **omega[i]**: 从顶点i开始破坏时移除的客户数量
- **作用**: 控制破坏-重构的强度
- **动态调整**:
  - 如果扰动后解质量太差，减少omega
  - 如果扰动后解质量太好，增加omega
  - 目标：保持适度的扰动强度

#### 模拟退火温度
- **初始温度**: 平均边成本 × sa_initial_factor
- **最终温度**: 初始温度 × sa_final_factor
- **冷却策略**: 几何冷却，T(k) = T(0) × factor^k
- **作用**: 允许接受较差的解以逃离局部最优

## 算法特点

### 1. 自适应机制
- **粒度规则**: 动态调整搜索空间
- **扰动强度**: 自适应调整破坏-重构的强度
- **温度控制**: 模拟退火逐渐降低接受较差解的概率

### 2. 增量更新
- **LRU缓存**: 只更新最近修改的顶点相关的移动
- **Do/Undo列表**: 高效地应用和撤销修改
- **稀疏更新**: 只重新计算受影响的移动生成器

### 3. 多层次搜索
- **破坏-重构**: 大范围扰动，逃离局部最优
- **局部搜索**: 精细优化，找到局部最优
- **模拟退火**: 接受准则，平衡探索和利用

### 4. 稀疏化策略
- **粒度规则**: 只考虑k近邻
- **邻居限制**: 插入时只考虑邻居客户的路径
- **移动生成器**: 预计算和缓存有希望的移动

## 时间复杂度分析

### 预处理
- **邻居计算**: O(n² log n)，其中n是顶点数
- **移动生成器**: O(nk)，其中k是邻居数

### 每次迭代
- **破坏-重构**: O(ω × k)，其中ω是移除的客户数
- **局部搜索**: O(nk × m)，其中m是邻域算子数
- **参数更新**: O(n)

### 总体
- **时间复杂度**: O(T × nk × m)，其中T是迭代次数
- **空间复杂度**: O(n² + nk)

## 使用示例

```bash
# 基本用法
./filo2 instances/X-n101-k25.vrp

# 指定参数
./filo2 instances/X-n101-k25.vrp \
  --coreopt-iterations 200000 \
  --granular-neighbors 30 \
  --seed 42 \
  --outpath results/

# 快速测试
./filo2 instances/X-n101-k25.vrp \
  --coreopt-iterations 10000 \
  --routemin-iterations 100
```

## 输出文件

### .out文件
```
<目标值>\t<运行时间(秒)>
```

### .vrp.sol文件
```
Route #1: 1 2 3 4 5
Route #2: 6 7 8 9
...
Cost <目标值>
```

## 参考文献

FILO2算法的详细描述请参考原论文。


